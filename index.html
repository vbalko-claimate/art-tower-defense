<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Tower Defense with Optimized Pathfinding</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pathfinding@0.4.18/visual/lib/pathfinding-browser.min.js"></script>
    <style>
        #defaultCanvas0 {
            border: 1px solid black;
            background-color: #f0f0f0;
        }
        #stats {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="stats">
        <p id="waveInfo"></p>
        <p id="fortressHealth"></p>
        <p id="resources"></p>
        <p id="enemyInfo"></p>
        <button id="startButton" onclick="startNextWave()">Start Next Wave</button>
    </div>
    <script>
        let gridSize = 20;
        let cols, rows;
        let grid = [];
        let defenses = [];
        let enemies = [];
        let projectiles = [];
        let designMode = true;
        let fortressHealth = 100;
        let resources = 100;
        let currentWave = 0;
        let fortressX, fortressY;
        let enemiesInCurrentWave = 0;
        let enemiesCreated = 0;
        let enemiesDestroyed = 0;
        let finder;

        // Configuration for enemy types with 5x slower speed
        const ENEMY_TYPES = {
            type1: { speed: 0.04, appearance: '#FF0000', hitpoints: 100 },
            type2: { speed: 0.03, appearance: '#00FF00', hitpoints: 150 },
            type3: { speed: 0.05, appearance: '#0000FF', hitpoints: 50 },
        };

        // Waves configuration
        const waves = [
            { type: 'type1', count: 10 },
            { type: 'type2', count: 5 },
            { type: 'type3', count: 15 },
            { type: 'type1', count: 10, type: 'type3', count: 5 },
            // Add more waves as needed
        ];

        function setup() {
            createCanvas(800, 600);
            cols = Math.floor(width / gridSize);
            rows = Math.floor(height / gridSize);
            fortressX = Math.floor(cols / 2);
            fortressY = Math.floor(rows / 2);

            // Initialize the grid with cells
            for (let i = 0; i < cols; i++) {
                grid[i] = [];
                for (let j = 0; j < rows; j++) {
                    grid[i][j] = new Cell(i, j);
                }
            }

            // Make sure the center and surroundings are open
            grid[fortressX][fortressY].wall = false;
            grid[fortressX - 1][fortressY].wall = false;
            grid[fortressX + 1][fortressY].wall = false;
            grid[fortressX][fortressY - 1].wall = false;
            grid[fortressX][fortressY + 1].wall = false;

            // Initialize pathfinding.js grid and finder
            finder = new PF.AStarFinder({
                allowDiagonal: false,
                dontCrossCorners: true
            });

            updateStats();
        }

        function draw() {
            background('#f0f0f0');
            drawMaze();
            drawFortress();
            drawDefenses();
            if (!designMode) {
                moveEnemies();
                updateProjectiles();
                handleCombat();
                drawEnemies();
                drawProjectiles();
            }
        }

        function mousePressed() {
            if (designMode && resources >= 10) {
                let col = Math.floor(mouseX / gridSize);
                let row = Math.floor(mouseY / gridSize);
                if (col >= 0 && col < cols && row >= 0 && row < rows) { // Check bounds
                    if (grid[col] && grid[col][row] && grid[col][row].wall) { // Ensure within bounds and is a wall
                        defenses.push({ x: col, y: row, range: 100, damage: 5, cooldown: 30, cooldownTimer: 0 });
                        grid[col][row].wall = false; // Occupied by tower, no longer a wall
                        resources -= 10;
                        updateStats();
                    } else {
                        console.log(`Invalid placement: grid[${col}][${row}]`);
                    }
                }
            }
        }

        function startNextWave() {
            if (currentWave < waves.length) {
                designMode = false;
                enemiesInCurrentWave = 0;
                spawnEnemies(waves[currentWave]);
                currentWave++;
                updateStats();
            } else {
                alert('All waves completed!');
            }
        }

        function drawMaze() {
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    grid[i][j].show(color(255));
                }
            }
        }

        function drawFortress() {
            fill('#FFD700');
            rect(fortressX * gridSize, fortressY * gridSize, gridSize, gridSize);
            drawHealthBar(fortressX * gridSize, fortressY * gridSize - 5, fortressHealth, 100, 'red');
        }

        function drawDefenses() {
            fill('#0080FF');
            defenses.forEach(defense => {
                rect(defense.x * gridSize, defense.y * gridSize, gridSize, gridSize);
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                fill(enemy.appearance);
                rect(enemy.x * gridSize, enemy.y * gridSize, gridSize, gridSize);
                drawHealthBar(enemy.x * gridSize, enemy.y * gridSize - 5, enemy.health, enemy.maxHealth, 'green');
                drawPath(enemy.path);
            });
        }

        function drawProjectiles() {
            projectiles.forEach(projectile => {
                fill('#FFD700');
                ellipse(projectile.x, projectile.y, 5, 5);
            });
        }

        function drawHealthBar(x, y, current, max, color) {
            fill(color);
            rect(x, y, gridSize * (current / max), 5);
            noFill();
            stroke(0);
            rect(x, y, gridSize, 5);
            noStroke();
        }

        function drawPath(path) {
            if (path) {
                noFill();
                stroke('rgba(255, 0, 0, 0.15)');
                strokeWeight(2);
                beginShape();
                for (let i = 0; i < path.length; i++) {
                    vertex(path[i][0] * gridSize + gridSize / 2, path[i][1] * gridSize + gridSize / 2);
                }
                endShape();
                noStroke();
            }
        }

        function spawnEnemies(wave) {
            const { type, count } = wave;
            const enemyConfig = ENEMY_TYPES[type];

            for (let i = 0; i < count; i++) {
                let startX = 0;
                let startY = Math.floor(random(rows));
                if (startY >= 0 && startY < rows && grid[startX] && grid[startX][startY] && !grid[startX][startY].wall) { // Ensure within bounds and not a wall
                    let pfGrid = new PF.Grid(cols, rows);
                    // Set walls in pfGrid
                    for (let x = 0; x < cols; x++) {
                        for (let y = 0; y < rows; y++) {
                            if (grid[x][y].wall) {
                                pfGrid.setWalkableAt(x, y, false);
                            }
                        }
                    }

                    let path = finder.findPath(startX, startY, fortressX, fortressY, pfGrid);
                    if (path && path.length > 0) { // Ensure path exists
                        enemies.push({
                            x: startX,
                            y: startY,
                            health: enemyConfig.hitpoints,
                            maxHealth: enemyConfig.hitpoints,
                            speed: enemyConfig.speed,
                            appearance: enemyConfig.appearance,
                            path: path,
                            step: 0
                        });
                        enemiesInCurrentWave++;
                        enemiesCreated++;
                    } else {
                        console.log(`No path found for enemy at startX: ${startX}, startY: ${startY}`);
                    }
                } else {
                    console.log(`Invalid spawn location: startX: ${startX}, startY: ${startY}`);
                }
            }
            updateStats();
        }

        function moveEnemies() {
            enemies.forEach((enemy, index) => {
                if (enemy.path && enemy.path.length > 0) {
                    let target = { x: enemy.path[enemy.step][0], y: enemy.path[enemy.step][1] };
                    let dx = target.x - enemy.x;
                    let dy = target.y - enemy.y;
                    let distance = dist(enemy.x, enemy.y, target.x, target.y);
                    if (distance > 0.1) {
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                    } else {
                        enemy.step++;
                        if (enemy.step >= enemy.path.length) {
                            fortressHealth -= 10;
                            enemies.splice(index, 1);
                            enemiesDestroyed++;
                            updateStats();
                            if (fortressHealth <= 0) {
                                noLoop();
                                alert('Game Over! The fortress has fallen.');
                            }
                        }
                    }
                } else {
                    console.log(`Invalid enemy path for enemy at index: ${index}`);
                }
            });
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let projectile = projectiles[i];
                projectile.move();

                // Check for collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let enemy = enemies[j];
                    let d = dist(projectile.x, projectile.y, enemy.x * gridSize, enemy.y * gridSize);
                    if (d < gridSize / 2) { // Collision detected
                        let damage = Math.min(enemy.health, projectile.damage);
                        enemy.health -= damage;
                        resources += damage; // Add resources equal to damage dealt
                        if (enemy.health <= 0) {
                            enemies.splice(j, 1);
                            enemiesDestroyed++;
                            updateStats();
                        }
                        projectiles.splice(i, 1); // Remove projectile on hit
                        break;
                    }
                }

                // Remove projectiles that move off-screen
                if (projectile.x < 0 || projectile.x > width || projectile.y < 0 || projectile.y > height) {
                    projectiles.splice(i, 1);
                }
            }
            updateStats(); // Update stats to reflect new resources
        }

        function handleCombat() {
            defenses.forEach(defense => {
                if (defense.cooldownTimer === 0) {
                    let target = findTarget(defense);
                    if (target) {
                        let angle = atan2(target.y * gridSize - defense.y * gridSize, target.x * gridSize - defense.x * gridSize);
                        let projectile = new Projectile(defense.x * gridSize + gridSize / 2, defense.y * gridSize + gridSize / 2, angle, defense.damage);
                        projectiles.push(projectile);
                        defense.cooldownTimer = defense.cooldown; // Reset cooldown
                    }
                } else {
                    defense.cooldownTimer--;
                }
            });
        }

        function findTarget(defense) {
            let closest = null;
            let closestDist = defense.range;
            enemies.forEach(enemy => {
                let d = dist(defense.x, defense.y, enemy.x, enemy.y);
                if (d < closestDist) {
                    closestDist = d;
                    closest = enemy;
                }
            });
            return closest;
        }

        function updateStats() {
            document.getElementById('waveInfo').innerText = `Current Wave: ${currentWave + 1} / ${waves.length}`;
            document.getElementById('fortressHealth').innerText = `Fortress Health: ${fortressHealth}`;
            document.getElementById('resources').innerText = `Resources: ${resources}`;
            document.getElementById('enemyInfo').innerText = `Enemies in Current Wave: ${enemiesInCurrentWave}, Created: ${enemiesCreated}, Destroyed: ${enemiesDestroyed}`;
        }

        // Helper function to create a new cell object
        function Cell(i, j) {
            this.i = i;
            this.j = j;
            this.wall = random(1) < 0.3;
            this.f = 0;
            this.g = 0;
            this.h = 0;
            this.neighbors = [];
            this.previous = undefined;

            this.show = function (col) {
                fill(col);
                if (this.wall) fill(0);
                noStroke();
                rect(this.i * gridSize, this.j * gridSize, gridSize - 1, gridSize - 1);
            };

            this.addNeighbors = function (grid) {
                let i = this.i;
                let j = this.j;
                if (i < cols - 1) this.neighbors.push(grid[i + 1][j]);
                if (i > 0) this.neighbors.push(grid[i - 1][j]);
                if (j < rows - 1) this.neighbors.push(grid[i][j + 1]);
                if (j > 0) this.neighbors.push(grid[i][j - 1]);
            };
        }

        // Projectile class
        class Projectile {
            constructor(x, y, angle, damage) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 5;
                this.damage = damage;
            }

            move() {
                this.x += cos(this.angle) * this.speed;
                this.y += sin(this.angle) * this.speed;
            }
        }
    </script>
</body>
</html>
